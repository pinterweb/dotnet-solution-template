# BusinessApp
> $(product_description)

_generated by: https://github.com/pinterweb/dotnet-solution-template_

## Summary

This solution is a layered C# solution that separates concerns by function to
isolate dependencies. The kernel & analyzer projects are at the very bottom layer,
providing support for all projects. Infrastructure code is separated out depending
on its function to isolate dependencies and function. To find out more information
on a project, see the READMEs:

## Projects

[Analyzers](./src/BusinessApp.Analyzers): Code generators to make your
life easier\
[Api](./src/BusinessApp.Api): Your app's business logic\
[CompositionRoot](./src/BusinessApp.CompositionRoot): Registers all services\
[Infrastructure](./src/BusinessApp.Infrastructure): Services to support
your app's business logic\
//#if efcore
[Infrastructure.Persistence](./src/BusinessApp.Infrastructure.Persistence):
Services to support persisting and querying data with entity framework core\
//#endif
[Kernel](./src/BusinessApp.Kernel):The core code shared by all projects\
[WebApi](/CSharp/src/BusinessApp.WebApi): The runnable aspnet web api entrypoint\

## Getting Started

- Create your query & commands models in the Api project
//#if efcore
- Setup `IEntityConfiguration<TModel>` classes for any query contracts and
  commands.
//#if metadata
    - Command data is automatically saved to the database.
//#endif
    - Query contracts are queried by entity framework.
- Run .\migrations_add to setup your database and .\migration_add_new in your
  test project
//#endif
- Create routes in `Routes.cs` located in the WebApi project\
  _note: Any requests inheriting from `IQuery` returning an `IEnumerable`, will_
  _be handled by an `IRequestHandler<T, EnvelopeContract<TResponse>>`_
//#if (!efcore)
- Create a `IRequestHandler<TRequest, TResponse>` in the Api project to handle
   queries and commands.\
   _there is no data persistence, so you will have to set that up yourself_
//#endif
//#if efcore
- Optional: Create a `IRequestHandler<TRequest, TResponse>` in the Api project
  to handle any business logic.\
//#if metadata
   _this step is optional if you just want to save the command data. A generic_
   _request handler will run and save the command data to a database if you_
   _configure the command in an `IEntityConfiguration<TModel>` class._
//#endif
   _Query objects inheriting from `IQuery` will already have a request_
   _handler to run the query. Make sure to setup your query contracts in an_
   _`IEntityConfiguration<TModel>` class first._
//#endif
   _You can use the Bogus library if you want to bypass data persistence_,
   _just be sure to setup your own request handler to generate this fake data_
//#if docker
### Docker
**Review the .env.example file to see the variables needed to run with docker**

- To develop in the container run `docker-compose -f
  docker-compose.development.yml run --rm --service-ports purchaseorderitemreceiver bash`
  to enter the container. Within the container run `dotnet watch run --launch-profile Docker`.\
  to hit the API from your host machine
- To run a container run `docker-compose -f docker-compose.development.yml up`
//#endif
//#if (!docker)
- Run `dotnet watch run`
//#endif
