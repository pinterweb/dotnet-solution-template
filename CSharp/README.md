# BusinessApp
> _$(product_description)_

_generated by: https://github.com/pinterweb/dotnet-solution-template_

## Summary

This solution is a layered C# solution that separates concerns by function to
isolate dependencies. The kernel & analyzer projects are at the very bottom layer,
providing support for all projects. Infrastructure code is separated out depending
on its function to isolate dependencies and function. To find out more information
on a project, see the READMEs:

## Projects

[CompositionRoot](/CSharp/src/BusinessApp.CompositionRoot): Registers all services\
[WebApi](/CSharp/src/BusinessApp.WebApi): The runnable aspnet web api entrypoint\
//#if efcore
[Infrastructure.Persistence](/CSharp/src/BusinessApp.Infrastructure.Persistence):
Services to support persisting and querying data with entity framework core\
//#endif
[Api](/CSharp/src/BusinessApp.Api): Your app's business logic\
[Infrastructure](/CSharp/src/BusinessApp.Infrastructure): Services to support
your app's business logic\
[Analyzers](/CSharp/src/BusinessApp.Analyzers): Code generators to make your
life easier\
[Kernel](/CSharp/src/BusinessApp.Kernel):The core code shared by all projects\

## Getting Started

- Commit your code to source control (e.g. `feat(all): Add initial infrastructure`)
- Add your continuous integration assets (e.g. azure-pipeline.yml)
- Commit your code to source control (e.g. `chore(build): Add build/release assets`)
- Create your query & commands models in the Api project
//#if efcore
- Setup `IEntityConfiguration<TModel>` classes for any query contracts and
  commands. Command data is automatically saved to the database and query
  contracts are queried by entity framework.
- Run .\migrations_add to setup your database
//#endif
- Create routes in `Routes.cs` located in the WebApi project\
  _note: Any requests inheriting from `IQuery` returning an `IEnumerable`, will_
  _be handled by an `IRequestHandler<T, EnvelopeContract<TResponse>>`_
//#if (!efcore)
- Create a `IRequestHandler<TRequest, TResponse>` in the Api project to handle
   queries and commands.\
   _there is no data persistence, so you will have to set that up yourself_
//#endif
//#if efcore
- Optional: Create a `IRequestHandler<TRequest, TResponse>` in the Api project\
   _this step is optional if you just want to save the command data. A generic_
   _request handler will run and save the command data to a database if you_
   _configure the command in an `IEntityConfiguration<TModel>` class._
   _Similarly, query objects inheriting from `IQuery` will already have a request_
   _handler to run the query. Make sure to setup your query contracts in an_
   _`IEntityConfiguration<TModel>` class first._
//#endif
   _You can use the Bogus library if you want to bypass data persistence_,
   _just be sure to setup your own request handler to generate this fake data_
//#if docker
- Run `docker-compose up` from the src directory.\
  _the webapi image depends on the db image. However, if you have a local sql
  _server you would like to use instead, you can change the "db" server name_
  _to "host.docker.internal" to target your host machine database_
//#endif
//#if (!docker)
- Run `dotnet watch run`
//#endif
